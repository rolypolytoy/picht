=======================
Computational Physics
=======================

This document explains the computational physics methods and theoretical foundations used in Picht for simulating charged particle trajectories through electrostatic fields.

Mathematical Formulation
========================

Electrostatic Field Equations
-----------------------------

Picht solves the electrostatic potential using Laplace's equation in cylindrical coordinates:

.. math::

   \nabla^2 \phi = \frac{\partial^2 V}{\partial z^2} + \frac{\partial^2 V}{\partial r^2} + \frac{1}{r}\frac{\partial V}{\partial r} = 0

where V is the electrostatic potential, :math:`z` is the axial coordinate, and :math:`r` is the radial coordinate. It uses multigrid methods using PyAMG to solve the system of equations generated by the Laplacian, and then solves:

.. math::

   E = -\nabla V

To find the electric field from the potential field. 

Boundary Conditions
~~~~~~~~~~~~~~~~~~~

The system employs Dirichlet boundary conditions:

.. math::

   \phi(\mathbf{r}) = V_0 \quad \text{on electrode surfaces}

   \phi(\mathbf{r}) = 0 \quad \text{on outer boundaries}

This effectively makes sure that not only do the electrodes have the proper potentials, but that the boundaries are treated like grounded metal, to simulate a real vacuum chamber's interior. 

Particle Dynamics
-----------------

Relativistic Equations of Motion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Picht uses the relativistic formulation for particle dynamics:

.. math::

   \frac{d\mathbf{p}}{dt} = q\mathbf{E}

where the momentum is:

.. math::

   \mathbf{p} = \gamma m \mathbf{v}

and the Lorentz factor is:

.. math::

   \gamma = \frac{1}{\sqrt{1 - v^2/c^2}}

This is straightforwardly how relativistic physics are calculated, and adds minimal overhead to the calculation.

Energy-Momentum Relation
~~~~~~~~~~~~~~~~~~~~~~~~

The total energy of a particle is:

.. math::

   E^2 = (pc)^2 + (mc^2)^2

Velocity from momentum:

.. math::

   \mathbf{v} = \frac{\mathbf{p}c^2}{E}

Numerical Methods
=================

Finite Difference Method (FDM)
------------------------------

Spatial Discretization
~~~~~~~~~~~~~~~~~~~~~~

The Laplacian operator is discretized using central differences:

.. math::

   \frac{\partial^2 \phi}{\partial z^2} \approx \frac{\phi_{i+1,j} - 2\phi_{i,j} + \phi_{i-1,j}}{\Delta z^2}

   \frac{\partial^2 \phi}{\partial r^2} \approx \frac{\phi_{i,j+1} - 2\phi_{i,j} + \phi_{i,j-1}}{\Delta r^2}

   \frac{1}{r}\frac{\partial \phi}{\partial r} \approx \frac{1}{r_j}\frac{\phi_{i,j+1} - \phi_{i,j-1}}{2\Delta r}

We use the finite difference method over the boundary element method because it's faster for geometries of a relatively simplistic nature.

Grid Structure
~~~~~~~~~~~~~~

- Uniform rectangular grid in :math:`(z,r)` coordinates
- Grid spacing: :math:`\Delta z = L_z/N_z`, :math:`\Delta r = L_r/N_r`
- Cylindrical symmetry assumption: :math:`\partial/\partial\theta = 0`

So, any cylindrically asymmetric lenses cannot be simulated.

Matrix Formulation
~~~~~~~~~~~~~~~~~~

The discretized Laplace equation forms a sparse linear system:

.. math::

   \mathbf{A}\boldsymbol{\phi} = \mathbf{b}

where :math:`\mathbf{A}` is the discretized Laplacian operator matrix. This is simply to be able to solve it extremely quickly with PyAMG. 


Multigrid Solver (PyAMG)
------------------------

Picht uses Algebraic Multigrid (AMG) methods for efficient solution:

Algorithm Overview
~~~~~~~~~~~~~~~~~~

1. **Smoothing**: Jacobi or Gauss-Seidel iterations reduce high-frequency errors
2. **Restriction**: Transfer residual to coarser grid
3. **Coarse grid correction**: Solve on coarse grid
4. **Prolongation**: Interpolate correction back to fine grid
5. **Post-smoothing**: Additional smoothing iterations

For more information about what this relates, refer to PyAMG's documentation: https://pyamg.saclay.inria.fr/pyamg.html

Convergence Properties
~~~~~~~~~~~~~~~~~~~~~~

- :math:`O(N)` computational complexity (previously quadratic complexity when SOR was used, but multigrid reduces it to this)
- Convergence rate independent of grid size
- Default tolerance: :math:`||\mathbf{r}||_2 < 10^{-6}`

ODE Integration
---------------

Trajectory integration uses SciPy's BDF method with a default relative tolerance of 1e-9, and an absolute tolerance of 1e-12:

BDF Methods
~~~~~~~~~~~

For stiff problems (strong electric fields):

.. math::

   \sum_{i=0}^{k}\alpha_i\mathbf{y}_{n-i} = h\beta\mathbf{f}(\mathbf{y}_n, t_n)


Force Calculations
=======================

Picht does not use the paraxial ray equation, but uses the Lorentz force for electrostatic systems:

.. math::

   \mathbf{F} = q\mathbf{E}(z,r)

It uses, in fractional/decimal grid values, nearest-neighbor field lookup:

.. code-block:: python

   i = int(z / dz)
   j = int(r / dr)
   E_z = E_z_grid[i, j]
   E_r = E_r_grid[i, j]

Grid Resolution Guidelines
==========================

Recommended grid spacing:

.. math::

   \Delta z, \Delta r < \frac{\lambda_{min}}{10}

where :math:`\lambda_{min}` is the smallest feature size. You can comfortably have nz, nr > 1000 before significant slowdowns.
